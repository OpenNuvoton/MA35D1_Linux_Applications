/*
 * Copyright (c) 2022 Nuvoton technology corporation
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/ioctl.h>

#include "crypto-ioctl.h"

struct ecc_tv_keygen_t {
	char	name[32];
	int	curve;
	int	keylen;
	int	knum_d;
	u8	d[ECC_KMAXL];	/* private key (not used if select Key Store key) */
	u8	Qx[ECC_KMAXL];	/* public key X (not used if select Key Store key) */
	u8	Qy[ECC_KMAXL];	/* public key Y (not used if select Key Store key) */
} ;


/*======================================================================================*/
/*  Test vectors for ECC public key generation                                          */
/*======================================================================================*/
/*
 *  These two test vectors were generated by using jason file:
 *  {
 *      "key4": {
 *          "key": "fa2737fb93488d19caef11ae7faf6b7f4bcd67b286e3fc54e8a65c2b74aeccb0",
 *           "meta": "eccp256-cpu-readable"
 *      },
 *      "key5": {
 *          "key": "d4ccd6dae698208aa8c3a6f39e45510d03be09b2f124bfc067856c324f9b4d09",
 *          "meta": "eccp256-cpu-readable"
 *      }
 *  }
 */
struct ecc_tv_keygen_t tvec_key_gen[] = {
{
	"P-256", CURVE_P_256, 256,
	0x84,  /* OTP key number 4 */
	"b0ccae742b5ca6e854fce386b267cd4b7f6baf7fae11efca198d4893fb3727fa", /* reverse of the one in jason file */
	"f10b260232218628c0b6b5e6f65e2c56f1244ddd6d3e7278cb2063bea7da9223",
	"eb00acf7e205fe6ff5121b5b11dff7480569b1428c0e6b59502d92ed381e23ef",
},
{
	"P-256", CURVE_P_256, 256,
	0x85,  /* OTP key number 5 */
	"094d9b4f326c8567c0bf24f1b209be030d51459ef3a6c3a88a2098e6dad6ccd4",
	"837b7ec84db657df9404ec560ad384ef3c9cea11393b9c32935ea206ea668bba",
	"8a7557feddc4f225483ee8c41abb3f987aa9f58bdc49d79f27506f56e0275832",
},
};

int ecc_public_key_generation()
{
	int fd, i, len;
	struct timeval t0, t1;
	u8 str_buff[ECC_KMAXL];
	struct ecc_args_t args;
	int tt, ret;

	fd = open(NVT_ECC, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s!\n", NVT_ECC);
		return -1;
	}

	/*
	 *  Run ECC public key generation with private key from Key Store SRAM/OTP
	 */
	for (i = 0; i < sizeof(tvec_key_gen) / sizeof(tvec_key_gen[0]); i++) {
		printf("\n\nRun ECC %s public key generation with Key Store %s key %d ==>\n",
			tvec_key_gen[i].name, tvec_key_gen[i].knum_d & 0x80 ? "OTP" : "SRAM",
			tvec_key_gen[i].knum_d & ~0x80);

		memset(&args, 0, sizeof(args));
		args.curve = tvec_key_gen[i].curve;    /* specify ECC curve */
		args.keylen = tvec_key_gen[i].keylen;  /* specify key length */
		args.knum_d = tvec_key_gen[i].knum_d;  /* specify the private key number of from Key Store */

		gettimeofday(&t0, NULL);

		ret = ioctl(fd, ECC_IOC_KEY_GEN, &args);
		printf("ECC operation ret = %d\n", ret);

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);

		len = (args.keylen + 7) / 8;

		hex_to_cstr(args.out_x, len, str_buff);
		printf("[Result] X: %s\n", str_buff);
		hex_to_cstr(args.out_y, len, str_buff);
		printf("         Y: %s\n", str_buff);
	}

	/*
	 *  Run ECC public key generation with private key from user
	 */
	for (i = 0; i < sizeof(tvec_key_gen) / sizeof(tvec_key_gen[0]); i++) {
		printf("\n\nRun ECC %s public key generation with user key ==>\n", tvec_key_gen[i].name);

		memset(&args, 0, sizeof(args));
		args.curve = tvec_key_gen[i].curve;    /* specify ECC curve */
		args.keylen = tvec_key_gen[i].keylen;  /* specify key length */
		args.knum_d = -1;                      /* private key do not use Key Store */
		cstr_to_hex(tvec_key_gen[i].d, args.d, tvec_key_gen[i].keylen);

		gettimeofday(&t0, NULL);

		ret = ioctl(fd, ECC_IOC_KEY_GEN, &args);
		printf("ECC operation ret = %d\n", ret);

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);

		len = (tvec_key_gen[i].keylen + 7) / 8;

		hex_to_cstr(args.out_x, len, str_buff);
		printf("[Result] X: %s\n", str_buff);
		hex_to_cstr(args.out_y, len, str_buff);
		printf("         Y: %s\n", str_buff);
	}
	close(fd);
}

/*======================================================================================*/
/*  Test vectors for ECC ECDSA signature generation/verifiction                         */
/*======================================================================================*/
/*
 *  This public key of this test vector was programmed to Key Store OTP with the jason file:
 *  {
 *      "key3": {
 *          "key": "b0ccae742b5ca6e854fce386b267cd4b7f6baf7fae11efca198d4893fb3727fa",
 *          "meta": "eccp256-cpu-readable"
 *      },
 *      "key4": {
 *          "key": "094d9b4f326c8567c0bf24f1b209be030d51459ef3a6c3a88a2098e6dad6ccd4",
 *          "meta": "eccp256-cpu-readable"
 *      }
 *  }
 */
struct ecc_args_t tvec_sig[] = {
{
	CURVE_P_256, 256,
	-1,
	0x83, 0x84,  /* OTP key number 3, 4 */
	"be34baa8d040a3b991f9075b56ba292f755b90e4b6dc10dad36715c33cfdac25", /* private key */
	"fa2737fb93488d19caef11ae7faf6b7f4bcd67b286e3fc54e8a65c2b74aeccb0", /* public key X */
	"d4ccd6dae698208aa8c3a6f39e45510d03be09b2f124bfc067856c324f9b4d09", /* public key Y */
	"a3f91ae21ba6b3039864472f184144c6af62cd0e",                         /* SHA-1 digest */
	"18731ef637fe84872cf89a879567946a50f327f3af3aaeb6074a86f117e332b0", /* the random number used on generating this signature */
	"2b826f5d44e2d0b6de531ad96b51e8f0c56fdfead3c236892e4d84eacfc3b75c", /* signature R */
	"a2248b62c03db35a7cd63e8a120a3521a89d3d2f61ff99035a2148ae32e3a248", /* signature S */
},
};

int ecc_signature_verification()
{
	int fd, i, len;
	struct timeval t0, t1;
	struct ecc_args_t args;
	int tt, ret;

	fd = open(NVT_ECC, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s!\n", NVT_ECC);
		return -1;
	}

	/*
	 *  Run ECC signature verification with public key from user
	 */
	for (i = 0; i < sizeof(tvec_sig) / sizeof(tvec_sig[0]); i++) {
		printf("\n\nRun ECC signature verification with user key ==>\n");

		memset(&args,0, sizeof(args));

		args.curve = tvec_sig[i].curve;
		args.keylen = tvec_sig[i].keylen;
		args.knum_d = -1;
		args.knum_x = -1;	/* public key do not use Key Store */
		args.knum_y = -1;	/* public key do not use Key Store */
		strcpy(args.sha_dgst, tvec_sig[i].sha_dgst);
		strcpy(args.Qx, tvec_sig[i].Qx);
		strcpy(args.Qy, tvec_sig[i].Qy);
		strcpy(args.R, tvec_sig[i].R);
		strcpy(args.S, tvec_sig[i].S);

		gettimeofday(&t0, NULL);

		ret = ioctl(fd, ECC_IOC_SIG_VERIFY, &args);
		if (ret)
			printf("ECC signature verification failed ret = %d\n", ret);
		else
			printf("ECC signature verification passed.\n");

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);
	}

	/*
	 *  Run ECC signature verification with public key from Key Store SRAM/OTP
	 */
	for (i = 0; i < sizeof(tvec_sig) / sizeof(tvec_sig[0]); i++) {
		printf("\n\nRun ECC signature verification with Key Store %s-%d and %s-%d ==>\n",
			tvec_sig[i].knum_x & 0x80 ? "OTP" : "SRAM",
			tvec_sig[i].knum_x & ~0x80,
			tvec_sig[i].knum_y & 0x80 ? "OTP" : "SRAM",
			tvec_sig[i].knum_y & ~0x80);

		memset(&args,0, sizeof(args));

		args.curve = tvec_sig[i].curve;
		args.keylen = tvec_sig[i].keylen;
		args.knum_x = tvec_sig[i].knum_x;
		args.knum_y = tvec_sig[i].knum_y;
		strcpy(args.sha_dgst, tvec_sig[i].sha_dgst);
		// strcpy(args.Qx, tvec_sig[i].Qx);   /* use Key Store instead */
		// strcpy(args.Qy, tvec_sig[i].Qy);   /* use Key Store instead */
		strcpy(args.R, tvec_sig[i].R);
		strcpy(args.S, tvec_sig[i].S);

		gettimeofday(&t0, NULL);

		ret = ioctl(fd, ECC_IOC_SIG_VERIFY, &args);
		if (ret)
			printf("ECC signature verification failed ret = %d\n", ret);
		else
			printf("ECC signature verification passed.\n");

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);
	}

	/*
	 *  Run ECC signature verification with public key from user
	 */
	for (i = 0; i < sizeof(tvec_sig) / sizeof(tvec_sig[0]); i++) {
		printf("\n\nRun ECC signature verification with wrong user key ==>\n");

		memset(&args,0, sizeof(args));

		args.curve = tvec_sig[i].curve;
		args.keylen = tvec_sig[i].keylen;
		args.knum_x = -1;	/* public key do not use Key Store */
		args.knum_y = -1;	/* public key do not use Key Store */
		strcpy(args.sha_dgst, tvec_sig[i].sha_dgst);
		strcpy(args.Qx, tvec_sig[i].Qx);
		strcpy(args.Qy, tvec_sig[i].Qy);
		strcpy(args.R, tvec_sig[i].R);
		strcpy(args.S, tvec_sig[i].S);

		gettimeofday(&t0, NULL);

		memset(args.Qx, 3, 0x22);	/* update Qx and expect verification should be failed */

		ret = ioctl(fd, ECC_IOC_SIG_VERIFY, &args);
		if (ret)
			printf("ECC signature verification failed as expected. ret = %d\n", ret);
		else
			printf("ERROR!! ECC signature verification should not pass.\n");

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);
	}

	close(fd);
}

int ecc_signature_generation()
{
	int fd, i, len;
	struct timeval t0, t1;
	struct ecc_args_t args;
	int tt, ret;

	fd = open(NVT_ECC, O_RDWR);
	if (fd < 0) {
		printf("Failed to open %s!\n", NVT_ECC);
		return -1;
	}

	for (i = 0; i < sizeof(tvec_sig) / sizeof(tvec_sig[0]); i++) {
		printf("\n\nRun ECC signature verification with user key ==>\n");

		memset(&args,0, sizeof(args));

		args.curve = tvec_sig[i].curve;
		args.keylen = tvec_sig[i].keylen;
		args.knum_d = -1;
		strncpy(args.sha_dgst, tvec_sig[i].sha_dgst, ECC_KMAXL);
		strncpy(args.d, tvec_sig[i].d, ECC_KMAXL);
		strncpy(args.k, tvec_sig[i].k, ECC_KMAXL);

		gettimeofday(&t0, NULL);

		ret = ioctl(fd, ECC_IOC_SIG_GEN, &args);
		if (ret)
			printf("ECC signature generation failed ret = %d\n", ret);
		else
			printf("ECC signature generation done.\n");

		gettimeofday(&t1, NULL);
		tt = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;
		printf("PERFORMANCE: %d us\n", tt);

		printf("[Answer] R: %s\n", tvec_sig[i].R);
		printf("         S: %s\n", tvec_sig[i].S);
		printf("[Result] R: %s\n", args.R);
		printf("         S: %s\n", args.S);
	}
	printf("Test OK.\n");
	close(fd);
}
